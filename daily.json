/**
 * Daily Five (progressive difficulty)
 * - Fetch 2 easy, 2 medium, 1 hard from OpenTriviaDB
 * - Deterministically shuffle options per-day (ET)
 * - Maintain GLOBAL dayIndex starting at START_DAY
 */

const fs = require('fs');
const path = require('path');

// Set once: the date that should be "Day 1" in ET.
const START_DAY = "20250824"; // YYYYMMDD

function yyyymmdd(d = new Date(), tz = 'America/New_York') {
  const parts = new Intl.DateTimeFormat('en-CA', {
    timeZone: tz, year: 'numeric', month: '2-digit', day: '2-digit'
  }).formatToParts(d).reduce((a, p) => (a[p.type] = p.value, a), {});
  return `${parts.year}${parts.month}${parts.day}`;
}

function toUTCDate(yyyyMMdd) {
  const y = Number(yyyyMMdd.slice(0,4));
  const m = Number(yyyyMMdd.slice(4,6));
  const d = Number(yyyyMMdd.slice(6,8));
  return new Date(Date.UTC(y, m - 1, d));
}

// Deterministic PRNG + shuffle
function mulberry32(seed) {
  return function() {
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function seededShuffle(arr, seedNum) {
  const rand = mulberry32(seedNum);
  const out = [...arr];
  for (let i = out.length - 1; i > 0; i--) {
    const j = Math.floor(rand() * (i + 1));
    [out[i], out[j]] = [out[j], out[i]];
  }
  return out;
}

// Simple HTML entity decode (OpenTDB returns encoded strings sometimes)
function htmlDecode(s) {
  if (typeof s !== 'string') return s;
  return s
    .replaceAll('&quot;', '"')
    .replaceAll('&#039;', "'")
    .replaceAll('&amp;', '&')
    .replaceAll('&eacute;', 'é')
    .replaceAll('&rsquo;', '’')
    .replaceAll('&ldquo;', '“')
    .replaceAll('&rdquo;', '”')
    .replaceAll('&hellip;', '…')
    .replaceAll('&lt;', '<')
    .replaceAll('&gt;', '>');
}

async function fetchWithTimeout(url, { timeoutMs = 9000 } = {}) {
  const ac = new AbortController();
  const id = setTimeout(() => ac.abort(), timeoutMs);
  try {
    return await fetch(url, { signal: ac.signal });
  } finally {
    clearTimeout(id);
  }
}

// Fetch N questions for a given difficulty
async function fetchByDifficulty(difficulty, n) {
  const url = `https://opentdb.com/api.php?amount=${n}&type=multiple&encode=url3986&difficulty=${difficulty}`;
  const res = await fetchWithTimeout(url);
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const data = await res.json();
  if (!data?.results?.length) throw new Error('Empty payload');
  // decode the url3986-encoded pieces
  return data.results.map(r => ({
    category: decodeURIComponent(r.category),
    difficulty: r.difficulty, // easy|medium|hard
    question: decodeURIComponent(r.question),
    correct_answer: decodeURIComponent(r.correct_answer),
    incorrect_answers: r.incorrect_answers.map(decodeURIComponent),
  }));
}

(async () => {
  const day = yyyymmdd();               // ET day stamp (YYYYMMDD)
  const seed = Number(day);
  const outPath = path.resolve('daily.json');

  // Global dayIndex (1-based) from START_DAY (everyone shares this)
  const diffDays = Math.max(0, Math.round(
    (toUTCDate(day) - toUTCDate(START_DAY)) / 86400000
  ));
  const dayIndex = 1 + diffDays;

  try {
    // Try progressive difficulties: 2 easy, 2 medium, 1 hard
    let easy = [], medium = [], hard = [];
    try { easy   = await fetchByDifficulty('easy',   2); }   catch {}
    try { medium = await fetchByDifficulty('medium', 2); }   catch {}
    try { hard   = await fetchByDifficulty('hard',   1); }   catch {}

    // If any bucket came back short, backfill with easiest available
    const totalHave = easy.length + medium.length + hard.length;
    if (totalHave < 5) {
      const need = 5 - totalHave;
      // First try more easy to fill
      try {
        const extra = await fetchByDifficulty('easy', need);
        // append to easy
        easy = easy.concat(extra).slice(0, Math.min(5, easy.length + extra.length));
      } catch {}
    }

    // Compose ordered list: easy → easy → medium → medium → hard
    // If a bucket is missing items, pull from the next easiest on hand.
    const take = (arr) => arr.length ? arr.shift() : null;
    const pickNext = (pref) => {
      if (pref === 'easy')   return take(easy)   || take(medium) || take(hard);
      if (pref === 'medium') return take(medium) || take(easy)   || take(hard);
      if (pref === 'hard')   return take(hard)   || take(medium) || take(easy);
    };

    const ordered = [
      pickNext('easy'),
      pickNext('easy'),
      pickNext('medium'),
      pickNext('medium'),
      pickNext('hard'),
    ].filter(Boolean);

    if (ordered.length < 5) throw new Error('Could not assemble 5 questions');

    // Normalize to your front-end shape + deterministic option shuffle
    const questions = ordered.map((q, idx) => {
      const options = seededShuffle(
        [q.correct_answer, ...q.incorrect_answers].map(htmlDecode),
        seed + idx * 7
      );
      const correctIdx = options.indexOf(htmlDecode(q.correct_answer));
      return {
        text: htmlDecode(q.question),
        options,
        correct: correctIdx,
        // (optional) keep meta if you ever want to show it:
        // category: q.category, difficulty: q.difficulty
      };
    });

    const payload = { day, dayIndex, questions };
    fs.writeFileSync(outPath, JSON.stringify(payload, null, 2));
    console.log('Wrote daily.json for', day, 'with dayIndex', dayIndex);

  } catch (err) {
    console.warn('Fetch failed:', err.message, '— preserving previous daily.json if present.');
    if (!fs.existsSync(outPath)) {
      const fallback = {
        day, dayIndex,
        questions: [
          { text: "What is the capital of France?", options: ["Paris","Rome","Madrid","Berlin"], correct: 0 },
          { text: "Who painted the Mona Lisa?", options: ["Leonardo da Vinci","Michelangelo","Raphael","Donatello"], correct: 0 },
          { text: "Which planet is known as the Red Planet?", options: ["Mars","Jupiter","Venus","Saturn"], correct: 0 },
          { text: "What is H2O commonly known as?", options: ["Water","Hydrogen","Oxygen","Salt"], correct: 0 },
          { text: "What is 9 × 9?", options: ["81","72","99","64"], correct: 0 }
        ]
      };
      fs.writeFileSync(outPath, JSON.stringify(fallback, null, 2));
      console.log('Wrote fallback daily.json for', day, 'with dayIndex', dayIndex);
    }
  }
})();
